Вот структура плана, опираясь на обсуждение из встречи.[1]

### 1. Деплой, сборка и установка

- Оформить нормальный CI/CD‑процесс: сборка внутри Docker, установка всех нативных либ, повторяемая среда сборки.[1]
- Подготовить install‑инструкции для Linux (Ubuntu 20/22) и Windows: шаги, зависимости, типовые ошибки.[1]
- Настроить make‑таргеты: `make test`, `make lint`, `make build`, `make release`, чтобы всё гонялось одной командой перед коммитом.[1]
- Вариант развития: добавить Nix flake/Devcontainer для разработчиков, но как необязательный путь.[1]

### 2. Работа с данными и архитектура модулей

- Чётко разделить компоненты:  
  - модуль загрузки и обновления исторических/тик‑данных;  
  - модуль хранения (Parquet/кэш);  
  - модуль реального времени (подписки на брокера, события);  
  - фронтовый слой (терминал/GUI/CLI).[1]
- Стандартизировать формат: архивы CSV → распаковка → парсинг → хранение в Parquet с единообразной схемой.[1]
- Вынести core‑модуль в «закрытый» стабильный слой: расчистить код, задокументировать, покрыть тестами ≥80–90%, относиться как к сторонней библиотеке.[1]
- Вариант развития: сделать отдельный data‑service (микросервис) с API для запросов исторических и текущих данных.[1]

### 3. Надёжность, стейт и восстановление

- Реализовать нормальное состояние системы: не только in‑memory, но и периодический дамп состояния в кэш/файл (каждые N секунд).[1]
- Описать и реализовать протокол восстановления: после падения робот поднимается, видит флаг «упал», читает кэш, восстанавливает сессию, ордера, настройки GUI, позиции.[1]
- Ввести чёткий контракт по сохранению ордеров: ордера и их состояния зеркалируются в хранилище с частым обновлением, чтобы при крэше не терять историю и PnL.[1]
- Вариант развития: сделать stateful‑слой с возможностью смены движка (file/binary store → embedded DB → внешняя БД).[1]

### 4. Обработка ошибок и UX для разработчика/пользователя

- Ввести человекочитаемые ошибки: чёткие сообщения по отсутствию данных, проблемам с API, конфигами, сборкой.[1]
- Задать политику «fail‑safe»: любая нестандартная ситуация не должна ломать систему, а должна аккуратно логироваться и возвращать контролируемый статус.[1]
- Добавить уровни логирования (debug/info/warn/error) и отдельный лог для критических инцидентов (потеря соединения, серия обрывов, невозможность восстановиться).[1]
- Вариант развития: сделать небольшой web/GUI‑лог‑вьювер для робота (состояние стратегий, подключения, последних ошибок).[1]

### 5. Тестирование и качество кода

- Систематизировать юнит‑ и интеграционные тесты в Rust: тесты рядом с модулями + отдельный тест‑раннер через Makefile.[1]
- Добавить проверку взаимодействий между сервисами (end‑to‑end сценарии: загрузка данных → запуск стратегии → обрыв соединения → восстановление).[1]
- Включить линтеры и форматтеры (clippy, rustfmt) в обязательный pre‑commit шаг.[1]
- Вариант развития: property‑based тестирование для критичных частей ядра (движок сигналов/стратегий, учёт позиций).[1]

### 6. Функционал робота и торгового контура

- Реализовать устойчивую торговую сессию: робот как long‑running агент, сам перезапускается при падении и сам поднимает своё состояние.[1]
- Продумать аварийное выключение: ручной «стоп‑кран» и автоматические условия (риск‑лимиты, нестабильность брокера, серия ошибок).[1]
- Продумать схему работы с несколькими счетами/стратегиями: разведение стратегий по счетам, балансировка капитала, недопущение конфликтующих ордеров.[1]
- Вариант развития: модуль оркестрации стратегий (worklist: список инструментов + набор стратегий для каждого инструмента, управление этим набором).[1]

### 7. Интерфейс: терминал, GUI, способы работы

- Минимальная цель: CLI/terminal‑режим с подключением по SSH, возможность запускать и мониторить робота на удалённом сервере.[1]
- Для core‑а — хардкорный подход: настройки через конфиги и документацию, минимум «гламурного» GUI.[1]
- При этом дать бинарники для «пощупать» без сборки: готовые сборки под Linux/Windows, чтобы люди могли протестировать без знания Rust.[1]
- Вариант развития: тонкий UI‑слой (Qt/egui/web) для визуализации графиков, состояний стратегий и ордеров, сохраняя ядро независимым.[1]

### 8. Риск‑менеджмент, дисклеймеры и юридическая часть

- Формализовать риски использования: отдельный раздел документации и пользовательское соглашение/дисклеймер.[1]
- В явном виде прописать, что все риски по торговле несёт пользователь, платформа ничего не гарантирует.[1]
- Описать сценарии возможных технических инцидентов (обрыв брокера, зависание API, ошибки робота) и ожидаемое поведение системы.[1]
- Вариант развития: отдельный модуль риск‑менеджмента (лимиты по позиции, просадке, объёму заявок, блокировка торговли при нарушении).[1]

### 9. Интеграции с брокерами и внешними системами

- Доработать интеграцию с Тинькофф: стабильная загрузка минутных/тиковых данных, устойчивое восстановление соединения, понятные ошибки.[1]
- Спланировать будущие источники данных: другие биржи и брокеры, унифицированный слой адаптеров к разным API.[1]
- Учесть риски брокера (отказ в приёме заявок, паузы, лимиты) и реакции системы на такие события.[1]
- Вариант развития: модуль абстракции брокеров (Broker API trait + реализации: Tinkoff, MOEX, др.), чтобы стратегии не зависели от конкретного провайдера.[1]

### 10. Стратегии и язык/DSL для стратегий

- Сейчас: стратегии на Rust — сложнее писать, но компилятор гарантирует типобезопасность и отсутствие падений.[1]
- Описать стандарты для стратегий: как они подключаются, как получают данные и отдают сигналы, какие инварианты обязаны соблюдать.[1]
- Вариант развития 1: облегчённый слой над Rust (макросы, шаблоны), чтобы уменьшить «многословность» стратегий.[1]
- Вариант развития 2: собственный DSL/скриптовый язык для стратегий поверх ядра (аналог подходов vectorbt / bt, но с бэкендом на Rust).[1]

### 11. Многотаймфреймовый и ZigZag‑анализ

- Закрепить в архитектуре MTF‑подход: хранение и синхронизация разных таймфреймов, события по ZigZag‑модели как «фильтры» для принятия решений.[1]
- Сконцентрироваться на устойчивых, «человеко‑интуитивных» закономерностях: сочетание фильтров, которые очевидны трейдеру и воспроизводимы статистически.[1]
- Вариант развития: выделить модуль MTF/ZigZag‑аналитики как отдельный пакет, который можно использовать и вне торгового ядра.[1]

### 12. Документация и продуктовое видение

- Оформить продуктовое видение: для кого продукт (хардкор‑квант/разработчик), что он умеет сейчас, к чему идёт через 1–2 года.[1]
- Написать живой backlog в человекочитаемом виде: юзкейсы, сценарии, приоритизация фич, аргументация архитектурных решений.[1]
- Описать roadmap:  
  - этап 1 — ядро стабильно, данные загружаются, робот сам восстанавливается;  
  - этап 2 — удобный деплой, бинарники, первые внешние тестеры;  
  - этап 3 — расширенные интеграции, риск‑модуль, упрощённое написание стратегий.[1]
- Вариант развития: открытый roadmap + поиски единомышленников через профильные комьюнити после первого более‑менее стабильного релиза.[1]

[1](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/78638541/4559392c-83fa-4c79-84c8-0ed9b9b82999/20251122_2025-11-22_19-23-55-avin-deploy.txt)
